# Object-Oriented Programming in Python ðŸ

[![Python Version](https://img.shields.io/badge/python-3.6%2B-blue.svg)](https://www.python.org/downloads/)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![Contributions Welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)](CONTRIBUTING.md)

> A comprehensive guide to mastering Object-Oriented Programming (OOP) concepts in Python, from basic classes to advanced design patterns.

## ðŸ“š Table of Contents

- [Overview](#overview)
- [Learning Path](#learning-path)
- [Hour 1: The Building Blocks](#hour-1-the-building-blocks)
  - [Classes and Objects](#classes-and-objects)
  - [Instance Variables and Methods](#instance-variables-and-methods)
  - [Class Variables and Methods](#class-variables-and-methods)
  - [Constructors and Destructors](#constructors-and-destructors)
- [Hour 2-3: Building Relationships](#hour-2-3-building-relationships)
  - [Single Inheritance](#single-inheritance)
  - [Multilevel & Hierarchical Inheritance](#multilevel--hierarchical-inheritance)
  - [Multiple Inheritance & MRO](#multiple-inheritance--method-resolution-order)
- [Hour 4: Encapsulation and Structure](#hour-4-encapsulation-and-structure)
  - [Access Specifiers](#access-specifiers)
  - [Name Mangling](#name-mangling)
  - [Inner/Nested Classes](#innernested-classes)
  - [Object Relationships](#object-relationships)
- [Capstone Project](#capstone-project)
- [Getting Started](#getting-started)
- [Contributing](#contributing)

## ðŸŽ¯ Overview

This repository contains a structured learning path for Object-Oriented Programming in Python. Whether you're a beginner looking to understand the basics or an experienced developer wanting to deepen your OOP knowledge, this guide provides practical examples and exercises.

**Key Features:**
- ðŸ“– Comprehensive explanations with real-world analogies
- ðŸ’» Practical code examples for every concept
- ðŸ§  Thought-provoking questions to reinforce learning
- ðŸ—ï¸ Hands-on capstone project
- ðŸŽ¯ Progressive difficulty levels

## ðŸ—“ï¸ Learning Path

### **Total Duration:** 4+ Hours
- **Hour 1:** Foundation concepts (Classes, Objects, Methods)
- **Hour 2-3:** Inheritance patterns and relationships
- **Hour 4:** Advanced concepts (Encapsulation, Composition)
- **Final Task:** University Management System project

---

## ðŸ—ï¸ Hour 1: The Building Blocks

### Classes and Objects

> **Analogy:** A `class` is like a cookie cutter ðŸª. An `object` is the actual cookie made from that cutter.

A **class** serves as a blueprint or template for creating objects. It defines attributes (data) and methods (behaviors) that objects will have.

```python
# The Class (Blueprint)
class Dog:
    def __init__(self, name, breed):
        self.name = name      # Attribute
        self.breed = breed    # Attribute
    
    def bark(self):          # Method
        print(f"{self.name} says Woof!")

# Creating Objects (Instances)
my_dog = Dog("Buddy", "Golden Retriever")
your_dog = Dog("Lucy", "Poodle")

print(my_dog.name)  # Output: Buddy
your_dog.bark()     # Output: Lucy says Woof!
```

**ðŸ’¡ Think About It:** Design a `Car` class with three attributes and two methods. What would they be?

### Instance Variables and Methods

**Instance Variables:** Data unique to each object (like a student's name)
**Instance Methods:** Functions that operate on an object's data using `self`

```python
class Student:
    def __init__(self, name, student_id):
        self.name = name              # Instance variable
        self.student_id = student_id  # Instance variable
    
    def show_details(self):           # Instance method
        print(f"ID: {self.student_id}, Name: {self.name}")

# Usage
s1 = Student("Alice", "FTU001")
s2 = Student("Bob", "FTU002")
s1.show_details()  # Output: ID: FTU001, Name: Alice
```

**â“ Question:** Why is `self` required as the first parameter in instance methods?

### Class Variables and Methods

**Class Variables:** Shared data across all instances
**Class Methods:** Actions related to the class as a whole, using `cls`

```python
class Employee:
    company_name = "Innovate Inc."  # Class variable (shared by all)
    
    def __init__(self, name):
        self.name = name            # Instance variable (unique to each)
    
    @classmethod
    def get_company(cls):           # Class method
        return f"Company: {cls.company_name}"

# Usage
emp1 = Employee("John")
emp2 = Employee("Jane")
print(Employee.get_company())       # Output: Company: Innovate Inc.
```

**ðŸ’­ Consider:** When would you use a class variable instead of an instance variable?

### Constructors and Destructors

**Constructor (`__init__`):** Called automatically when an object is created
**Destructor (`__del__`):** Called when an object is about to be destroyed

```python
class FileHandler:
    def __init__(self, filename):
        print(f"CONSTRUCTOR: Opening '{filename}'...")
        self.file = open(filename, 'w')
    
    def __del__(self):
        print("DESTRUCTOR: Closing file...")
        self.file.close()

# Usage
log = FileHandler("app.log")  # Constructor called
# Destructor called automatically when 'log' goes out of scope
```

---

## ðŸ”— Hour 2-3: Building Relationships

### Single Inheritance

Creates an "is-a" relationship where a child class inherits from a parent class.

```python
class Vehicle:  # Parent class
    def start_engine(self):
        print("Engine starting...")
    
    def stop_engine(self):
        print("Engine stopping...")

class Car(Vehicle):  # Child class inherits from Vehicle
    def drive(self):
        print("Driving the car...")

# Usage
my_car = Car()
my_car.start_engine()  # Inherited method
my_car.drive()         # Own method
```

**ðŸŽ¯ Benefit:** Code reusability - no need to duplicate common functionality.

### Multilevel & Hierarchical Inheritance

**Multilevel:** Chain of inheritance (A â†’ B â†’ C)
**Hierarchical:** One parent, multiple children (A â†’ B, A â†’ C)

```python
# Multilevel Inheritance
class Organism:
    def breathe(self):
        print("Breathing...")

class Animal(Organism):
    def move(self):
        print("Moving...")

class Dog(Animal):  # Inherits from both Animal and Organism
    def bark(self):
        print("Barking...")

# Hierarchical Inheritance
class Shape:
    def area(self):
        pass

class Circle(Shape):    # Child 1
    def draw(self):
        print("Drawing circle")

class Square(Shape):    # Child 2 (sibling to Circle)
    def draw(self):
        print("Drawing square")
```

**ðŸ” Challenge:** Provide real-world examples of both inheritance types.

### Multiple Inheritance & Method Resolution Order

A class can inherit from multiple parent classes, combining their functionalities.

```python
class Swimmer:
    def swim(self):
        print("Swimming...")

class Flyer:
    def fly(self):
        print("Flying...")

class Duck(Swimmer, Flyer):  # Multiple inheritance
    def quack(self):
        print("Quacking...")

# Usage
donald = Duck()
donald.swim()   # From Swimmer
donald.fly()    # From Flyer
donald.quack()  # Own method

# Check Method Resolution Order
print(Duck.mro())  # Shows the search order for methods
```

**âš ï¸ Important:** MRO prevents ambiguity when multiple parents have methods with the same name.

---

## ðŸ”’ Hour 4: Encapsulation and Structure

### Access Specifiers

Python uses naming conventions to indicate intended access levels:

```python
class BankAccount:
    def __init__(self, balance):
        self.account_number = "12345"    # Public
        self._holder_name = "John Doe"   # Protected (convention)
        self.__balance = balance         # Private (name mangled)
    
    def get_balance(self):  # Public method to access private data
        return self.__balance

# Usage
account = BankAccount(1000)
print(account.account_number)    # âœ… Public - accessible
print(account._holder_name)      # âš ï¸ Protected - accessible but shouldn't
# print(account.__balance)       # âŒ Private - AttributeError
print(account.get_balance())     # âœ… Proper way to access private data
```

| Access Level | Notation | Description |
|--------------|----------|-------------|
| **Public** | `name` | Accessible everywhere (default) |
| **Protected** | `_name` | Internal use or subclasses only |
| **Private** | `__name` | Class use only (name mangled) |

### Name Mangling

Python automatically renames private attributes to prevent accidental access:

```python
class MyClass:
    def __init__(self):
        self.__secret = "top_secret"

obj = MyClass()
# print(obj.__secret)           # âŒ AttributeError
print(obj._MyClass__secret)     # âœ… Works (but don't do this!)
```

**ðŸ›¡ï¸ Purpose:** Prevents accidental override of private attributes in subclasses.

### Inner/Nested Classes

A class defined inside another class, used when one class is logically a component of another:

```python
class Car:
    def __init__(self, model):
        self.model = model
        self.engine = self.Engine("V8")  # Create inner class instance
    
    class Engine:  # Inner/Nested class
        def __init__(self, engine_type):
            self.type = engine_type
        
        def start(self):
            print(f"{self.type} engine starting...")

# Usage
my_car = Car("Mustang")
print(my_car.engine.type)    # Output: V8
my_car.engine.start()        # Output: V8 engine starting...
```

**ðŸ¤” Why nest classes?** When a class is only meaningful in the context of another class.

### Object Relationships

Different ways objects can be connected based on their lifecycles:

#### ðŸ”— Association ("uses-a")
Independent lifecycles - objects can exist separately.

```python
class Doctor:
    def __init__(self, name):
        self.name = name
    
    def treat(self, patient):
        print(f"Dr. {self.name} treating {patient.name}")

class Patient:
    def __init__(self, name):
        self.name = name

# Both can exist independently
doctor = Doctor("Smith")
patient = Patient("Alice")
doctor.treat(patient)
```

#### ðŸ“¦ Aggregation ("has-a")
The "part" can exist without the "whole".

```python
class Professor:
    def __init__(self, name):
        self.name = name

class Department:
    def __init__(self, name, professors):
        self.name = name
        self.professors = professors  # Department "has" professors
    
    def list_professors(self):
        for prof in self.professors:
            print(f"Professor: {prof.name}")

# Professors exist independently
prof1 = Professor("Dr. Turing")
prof2 = Professor("Dr. Lovelace")
cs_dept = Department("Computer Science", [prof1, prof2])
```

#### ðŸ” Composition ("owns-a")
The "part" is destroyed with the "whole" - stronger relationship.

```python
class Person:
    def __init__(self, name):
        self.name = name
        self.heart = self.Heart()  # Heart created inside Person
    
    class Heart:
        def __init__(self):
            self.beats_per_minute = 72
        
        def beat(self):
            print("Lub-dub")

# Heart cannot exist without Person
person = Person("John")
person.heart.beat()  # Heart is part of person
```

**ðŸ”‘ Key Difference:** In composition, the "part" is created and destroyed with the "whole".

---

## ðŸ† Capstone Project: University Management System

Build a comprehensive system demonstrating all OOP concepts learned:

### Requirements:

1. **Base Class:** Create a `Person` class with `name` and `age`
2. **Hierarchical Inheritance:** Create `Student` and `Professor` classes inheriting from `Person`
   - `Student` must have a private `__student_id`
   - `Professor` must have a protected `_employee_id`
3. **Class Variable:** Add `university_name` class variable to `Person`
4. **Composition & Nested Class:** Create a `Department` class with nested `Office` class
5. **Aggregation:** `Department` should accept a list of `Professor` objects
6. **Demonstration:** Create objects and show all relationships

### Sample Implementation:

```python
class Person:
    university_name = "Tech University"  # Class variable
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def display_info(self):
        print(f"Name: {self.name}, Age: {self.age}, University: {self.university_name}")

class Student(Person):  # Hierarchical inheritance
    def __init__(self, name, age, student_id):
        super().__init__(name, age)
        self.__student_id = student_id  # Private
    
    def get_student_id(self):
        return self.__student_id

class Professor(Person):  # Hierarchical inheritance
    def __init__(self, name, age, employee_id):
        super().__init__(name, age)
        self._employee_id = employee_id  # Protected
    
    def get_employee_id(self):
        return self._employee_id

class Department:
    def __init__(self, dept_name, professors):
        self.dept_name = dept_name
        self.professors = professors      # Aggregation
        self.office = self.Office("A101")  # Composition
    
    class Office:  # Nested class
        def __init__(self, room_number):
            self.room_number = room_number
        
        def get_location(self):
            return f"Room {self.room_number}"
    
    def list_faculty(self):
        print(f"\n{self.dept_name} Faculty:")
        for prof in self.professors:
            print(f"- {prof.name} (ID: {prof.get_employee_id()})")

# Demonstration
if __name__ == "__main__":
    # Create professors (exist independently)
    prof1 = Professor("Dr. Alan Turing", 45, "EMP001")
    prof2 = Professor("Dr. Ada Lovelace", 38, "EMP002")
    
    # Create department with aggregation
    cs_dept = Department("Computer Science", [prof1, prof2])
    
    # Create student
    student = Student("Alice Johnson", 20, "STU001")
    
    # Demonstrate all concepts
    print("=== University Management System ===")
    
    # Display person info
    prof1.display_info()
    student.display_info()
    
    # Show department faculty (aggregation)
    cs_dept.list_faculty()
    
    # Show office location (composition)
    print(f"Department Office: {cs_dept.office.get_location()}")
    
    # Access private member through method
    print(f"Student ID: {student.get_student_id()}")
```

---

## ðŸš€ Getting Started

### Prerequisites
- Python 3.6 or higher
- Basic understanding of Python syntax

### Installation
1. Clone this repository:
   ```bash
   git clone https://github.com/yourusername/python-oop-tutorial.git
   cd python-oop-tutorial
   ```

2. Run the examples:
   ```bash
   python examples/basic_classes.py
   python examples/inheritance_demo.py
   python capstone/university_system.py
   ```

### Repository Structure
```
python-oop-tutorial/
â”‚
â”œâ”€â”€ README.md                 # This comprehensive guide
â”œâ”€â”€ examples/                 # Code examples for each concept
â”‚   â”œâ”€â”€ basic_classes.py
â”‚   â”œâ”€â”€ inheritance_demo.py
â”‚   â”œâ”€â”€ encapsulation_demo.py
â”‚   â””â”€â”€ relationships_demo.py
â”‚
â”œâ”€â”€ capstone/                 # Final project
â”‚   â”œâ”€â”€ university_system.py
â”‚   â””â”€â”€ requirements.txt
â”‚
â”œâ”€â”€ exercises/                # Practice problems
â”‚   â”œâ”€â”€ beginner/
â”‚   â”œâ”€â”€ intermediate/
â”‚   â””â”€â”€ advanced/
â”‚
â””â”€â”€ docs/                     # Additional documentation
    â”œâ”€â”€ concepts.md
    â””â”€â”€ best_practices.md
```

## ðŸŽ¯ Learning Outcomes

After completing this tutorial, you will be able to:

- âœ… Design and implement classes with proper encapsulation
- âœ… Use inheritance to create maintainable code hierarchies  
- âœ… Apply composition and aggregation for complex relationships
- âœ… Understand and utilize Python's Method Resolution Order
- âœ… Implement access control using Python naming conventions
- âœ… Build real-world applications using OOP principles

## ðŸ¤ Contributing

We welcome contributions! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

### Ways to Contribute:
- ðŸ› Report bugs or issues
- ðŸ’¡ Suggest new examples or improvements
- ðŸ“ Improve documentation
- âœ¨ Add new exercises or projects

## ðŸ“œ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ðŸ™ Acknowledgments

- Inspired by real-world teaching experiences
- Thanks to the Python community for excellent documentation
- Special thanks to all contributors and learners

---

**Happy Coding! ðŸâœ¨**

> *"The best way to learn is by doing. Start with the basics, practice with examples, and build something amazing!"*
